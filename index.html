<!DOCTYPE html>
<meta charset="utf-8">
<head>
  <script src="./modules/emojibrush.js" crossorigin="anonymous"></script>
  <script src="./modules/emojicanvas.js" crossorigin="anonymous"></script>
  <script src="./twemoji.min.js" crossorigin="anonymous"></script>
  <script src="./multi-spectral-picker.min.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css">
  <link rel="stylesheet" type="text/css" href="./light.min.css">
  <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro&display=swap" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="style.css">
</head> 
<body>
  <h1>Emoji Painter</h1>
  <p>Draw an image using emoji<span class='brush'></span></p>
  <span id="example-anchor"></span>
  <input id="example" type="text"></input>
  <p class="emojiCanvas">EMPTY_CANVAS</p>
  <script>
    const CHAR_START = 128515
    const COLOR_SAMPLES = 32;
    const EMOJI_SAMPLES = 1000;
    let emojiCanvasElement = document.getElementsByClassName("emojiCanvas")[0];
    let brushCanvasElement = document.getElementsByClassName("brush")[0];
    let mouseButtonState = 0;

    let brush = new EmojiBrush(128515);
    brushCanvasElement.innerHTML = ' ' + brush.html;

    let emojiCanvas = new EmojiCanvas(emojiCanvasElement, 128515);

    let xRatio = emojiCanvas.width / emojiCanvas.canvasElement.getBoundingClientRect().width;
    let yRatio = emojiCanvas.height / emojiCanvas.canvasElement.getBoundingClientRect().height;

    let handleMousemove = (event) => {
      if (mouseButtonState % 2 == 1) {
        emojiCanvas.setPixel(brush.html, Math.floor(event.x*xRatio - 0.5), Math.floor(event.y*yRatio - emojiCanvas.canvasElement.getBoundingClientRect().top*yRatio));
      }
    };
    document.addEventListener('mousemove', handleMousemove);

    let handleMousewheel = (event) => {
      brush.brushInt += event.deltaY/Math.abs(event.deltaY);
      let count = 0;
      while(count < 1000 && !emojiCanvas.unitElementHasSameDimensionsAs(brush.brushInt)) {
        brush.brushInt += event.deltaY/Math.abs(event.deltaY);
        count++;
        if(count == 999) {
          console.warn("Brush overflow");
        }
      }
      brushCanvasElement.innerHTML = ' ' + brush.html;
      return false;
    }
    let canvasElement = emojiCanvas.canvasElement;
    canvasElement.addEventListener('wheel', handleMousewheel);

    let handleMouseDown = (event) => {
      mouseButtonState = event.buttons;
      let canvasElement = emojiCanvas.canvasElement;
      emojiCanvas.setPixel(brush.html, Math.floor(event.x*xRatio - 0.5), Math.floor(event.y*yRatio - canvasElement.getBoundingClientRect().top*yRatio));
    }
    //document.addEventListener('mousedown', handleMouseDown);

    let handleMouseUp = (event) => {
      mouseButtonState = event.buttons;
    }
    document.addEventListener('mouseup', handleMouseUp);

    var colorPickerMultiSpectral = new ColorPicker.MultiSpectral('#example', {
      format: 'rgb',
      size: 'small',
      inline: true,
      arrow: true,
      anchor: {
        hidden: true,
        cssProperty: 'color'
      }
    });

    let loadPalette = () => {
      charArray = [];
      colorMap = new Map();
      for(let i = 0; i<10000; i++) {
        if(emojiCanvas.unitElementHasSameDimensionsAs(CHAR_START + i)) {
          charArray.push(CHAR_START + i);
        }
      }
      charArray.forEach((charInt) => {
        // calculate character color
        let canvas = document.createElement('canvas');
        let context = canvas.getContext('2d');
        context.font = '48px serif';
        context.fillText(String.fromCharCode(charInt), 100, 100);
        colorMap.set(charInt, 'color here');
      });
      return colorMap;
    }
    let getAverageColor = (character) => {
      return color;
    }

    let map = loadPalette();
  </script>
</body>
